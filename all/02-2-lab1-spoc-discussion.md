# lec4: lab1 SPOC思考题

##**提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC的x86/RV内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### 启动顺序

1. x86段寄存器的字段含义和功能有哪些？
   (1)代码段寄存器 CS（Code Segment）存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏       移量则由IP提供
   (2)数据段寄存器 DS（Data Segment）指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址
   (3)堆栈段寄存器 SS（Stack Segment）指出当前堆栈的底部地址，即存放堆栈段的段基址
   (4)附加段寄存器 ES（Extra Segment）指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段
   (5)附加段寄存器 FS
   (6)附加段寄存器 GS
   
2. x86描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？
   *CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。
　 *RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。
　 *DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。
当进程访问一个段时，需要进程特权级检查，一般要求DPL >= max {CPL, RPL}

3. 分析可执行文件格式elf的格式（无需回答）

### 4.1 C函数调用的实现

### 4.2 x86中断处理过程

1. x86/RV中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？
   **硬件中斷處理過程1（起始）：從CPU收到中斷事件後，打斷當前程序或任務的執行，根據某種機制跳轉到中斷服務例程去執行的過程。其具體流程如下：
    *CPU在執行完當前程序的每一條指令後，都會去確認在執行剛才的指令過程中中斷控制器（如：8259A）是否發送中斷請求過來，如果有那麼CPU就會在相應的時鐘脈衝到來時從總線上讀取中斷請求對應的中斷向量；
    *CPU根據得到的中斷向量（以此為索引）到IDT中找到該向量對應的中斷描述符，中斷描述符裡保存著中斷服務例程的段選擇子；
    *CPU使用IDT查到的中斷服務例程的段選擇子從GDT中取得相應的段描述符，段描述符裡保存了中斷服務例程的段基址和屬性信息，此時CPU就得到了中斷服務例程的起始地址，並跳轉到該地址；
    *CPU會根據CPL和中斷服務例程的段描述符的DPL信息確認是否發生了特權級的轉換。比如當前程序正運行在用戶態，而中斷程序是運行在內核態的，則意味著發生了特權級的轉換，這時CPU會從當前程序的TSS信息（該信息在內存中的起始地址存在TR寄存器中）裡取得該程序的內核棧地址，即包括內核態的ss和esp的值，並立即將系統當前使用的棧切換成新的內核棧。這個棧就是即將運行的中斷服務程序要使用的棧。緊接著就將當前程序使用的用戶態的ss和esp壓到新的內核棧中保存起來；
    *CPU需要開始保存當前被打斷的程序的現場（即一些寄存器的值），以便於將來恢復被打斷的程序繼續執行。這需要利用內核棧來保存相關現場信息，即依次壓入當前被打斷程序使用的eflags，cs，eip，errorCode（如果是有錯誤碼的異常）信息；
    *CPU利用中斷服務例程的段描述符將其第一條指令的地址加載到cs和eip寄存器中，開始執行中斷服務例程。這意味著先前的程序被暫停執行，中斷服務程序正式開始工作。
   **硬件中斷處理過程2（結束）：每個中斷服務例程在有中斷處理工作完成後需要通過iret（或iretd）指令恢復被打斷的程序的執行。CPU執行IRET指令的具體過程如下：
    *程序執行這條iret指令時，首先會從內核棧裡彈出先前保存的被打斷的程序的現場信息，即eflags，cs，eip重新開始執行；
    *如果存在特權級轉換（從內核態轉換到用戶態），則還需要從內核棧中彈出用戶態棧的ss和esp，這樣也意味著棧也被切換回原先使用的用戶態的棧了；
    *如果此次處理的是帶有錯誤碼（errorCode）的異常，CPU在恢復先前程序的現場時，並不會彈出errorCode。這一步需要通過軟件完成，即要求相關的中斷服務例程在調用iret返回之前添加出棧代碼主動彈出errorCode。
    
2. 为什么在用户态的中断响应要使用内核堆栈？
   保护中断服务例程代码的安全。
   
3. x86中trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?
   *调用Interrupt Gate时，Interrupt会被CPU自动禁止
   *调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子
   *如果在设置上不做区分，会导致重复触发中断

### 4.3 练习四和五 ucore内核映像加载和函数调用栈分析

1. ucore中，在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？
   *ebp可以直接获得，若不内联则会得到错误的ebp值
   *而由于没有直接获取eip值的指令，我们需要利用call指令将eip压栈的特性，通过调用read_eip函数来读出压在栈上的eip的值。若将read_eip内联，则不会有函数调用存在，无法获得eip的值。

### 4.4 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？
   不是。CPU启动后，BIOS会在POST自检完成后在内存中建立中断向量表和中断服务程序。

## 开放思考题

1. 在ucore/rcore中如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？
2. 在ucore lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
3. GRUB是一个通用的x86 bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
4. 如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？

## 课堂实践
### 练习一
在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。

### 练习二
在ucore/rcore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。
